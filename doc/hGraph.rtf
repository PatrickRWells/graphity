{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww18140\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs36 \cf0 The hGraph, hList, and hNode classes\
\

\b0\fs22 The hGraph class specification (hGraph.h) and implementation (hGraph.cpp) actually include three separate classes:\
\
1. hGraph\
2. hList\
3. hNode\
\
The latter two are a simple linked list implementation that are used in the simulation module and will be discussed in a moment.\
\
Graph geometries, such as the Euler Characteristic and Dimensionality, are calculated as defined by Oliver Knill of Harvard University.\
\

\b\fs36 \cf2 The hGraph Class:\

\b0\fs22 \cf0 \
The hGraph class contains a number of attributes and methods. For information on how to write hamiltonians, see the appropriate document. \
\

\b\fs28 Attributes:\

\fs22 \

\b0 NUM_NODES: The number of nodes in the graph \
_eulerchar: the euler characteristic of the graph.\
_dimension: the dimensionality of the graph, as defined by Oliver Knill in \'93On the Dimensionality and Euler Characteristic of Random Graphs\'94\
_hamiltonian: the value of the hamiltonian last used on the graph object.\
_cliquesFound: Says whether or not the cliques have been searched for. Defaults to false.\

\b \

\b0 _adjMatrix: the adjacency matrix. Implemented using the Eigen library, which can be found in the lib folder.\
_degVector: a vector containing the degrees of each individual node on the graph. Uses the Eigen vector class.\
_numCliques a vector containing the number of cliques of every possible size, assuming they have been calculated. Defaults to all zeroes. \
\
\

\b\fs28 Constructors: \

\fs22 \

\b0 The hGraph node has three constructors. _eulerchar, _dimension, and _hamiltonian are (as of now) set to zero by all.\
\
hGraph(int size): takes an integer as its argument. Sets the size of the graph to the integer passed and initializes all adjacency matrix elements to zero\
hGraph(): takes no input. Sets the size of the adjacency matrix to 1x1. Useful if the size of the graphs will be decided later. See setMatrix below\
hGraph(int size, \cf2 \CocoaLigature0 MatrixXi adjMatrix): Sets the size of the adjAcency matrix to \'91size\'92 and propagates _adjMatrix and _degVector based on data passed to it;\\\
\

\b\fs28 How hamiltonians are calculated:\
\

\b0\fs22 Hamiltonians are defined by the user and can be found in the hamiltonians folder. Instructions for defining and using new hamiltonians can be found in the relevant documentation.\
\
The hGraph class uses a modified version of the visitor design patterns to use hamiltonians to calculate the energy of a particular graph. Essentially, the hamiltonians are plugins that can  be easily interchanged in a simulation without having to rewrite the simulation. Hamiltonians are defined as classes and all derive from the Abstract Hamiltonian superclass. To use the hamiltonian, a object of the hamiltonian type is created, and is passed to an hGraph using the accept function. The graph then calls the hamiltonian\'92s calculate function, passing itself as a parameter. The hamiltonian can then use functions implemented in the hGraph class to calculate the value, which it stores in its _result attribute. While this may seem to require extra work, it makes it extremely easy for the user to switch between hamiltonians when running a simulation, and allows the person writing the hamiltonian to define extra functions within the hamiltonians if the calculation required are particularly complex. Additionally it prevents unwanted side effects by doing the calculations based on a copy of the graph, rather than the graph itself, and then simply assigning the result to the appropriate attribute of the original graph object.\
\
This entire process is wrapped up in a single function, which is defined at the end of the hamiltonian. See the appropriate documentation for details \
\

\b\fs28 Inputting, outputting, and generating graphs: \

\b0 \

\b\fs24 I/O\

\fs28 \

\b0\fs22 The hGraph implementation contains a number of useful functions and overloaded operators to make the input, output, and generation of graphs easy and natural. The << operator behaves as usual regardless of if it is targeting a standard output (such as cout) or a file stream. When used with a standard output, the graph and its information will be printed in a human readable form. When used with a files stream, it will be outputted as a CSV, using the format specified below. The hGraph class contains two output methods - 
\b toFile 
\b0 and 
\b toStream. 
\b0 These are solely utility functions used in overloading the << operator. As such, they shouldn\'92t be used directly. \
\
The hGraph class additional contains a print() method, but it is no longer needed as its behavior is identical to sending a hGraph to standard output using the << operator.\
\

\b readGraphFile\
\

\b0 syntax \'97 hGraph * data = readGraphFile(int numRead)\

\b \

\b0 The readGraphFile function reads in graph data from a CSV given it by the user (such as one generated by the buildGraph module) and returns a pointer to the data read in, which can then be used in the usual ways.  Additionally, the integer passed to it as numRead will be changed to the number of graphs read. Note that the numRead variable must be declared prior to calling the function. The function prompts the user for the location of the file automatically. Note, this function can only read in files in the format used by the hGraph\'92s output methods, so it is best to generate these files using one of the included graph generation tools.\
\
\

\b\fs24 Graph generation\
\

\b0\fs22 The buildGraph module can be used to generate all graphs of a particular size and output them to a CSV file. This module can be used via the main Python script. Be careful though. It should not be used to generate graphs with more than 8 nodes, as the resultant file will likely exceed the amount of available disk space on most computers due to the incredibly large number of distinct graphs.\
\

\b Generation functions:\
\

\b0 There are two graph generation functions available. 
\b kGraph
\b0  takes as an input a single integer and returns a hGraph object (NOT a pointer to an hGraph object) that contains a complete graph with the number of nodes equal to the integer passed to the function call. 
\b randomGraph 
\b0 takes a single integer as a parameter and returns a randomly initialized graph with an edge probability between 0.25 and 1. Both functions were written to make it easy to test new functions, but can be used for any purpose. Both functions are generally quite quick, and have been tested with graphs of up to 100 nodes with no problems. 
\b\fs24 \

\fs22 \

\b0 \
\

\b getHam\
\

\b0 syntax \'97 graph.getHam();\
Returns the value of the most recent hamiltonian to operate on the graph as a double.\
\

\b setMatrix\
\

\b0 syntax \'97 graph.setMatrix(int size, MatrixXi data)\
	\
Resizes the matrix to the size passed, and populates the adjacency matrix and degree vector based on the matrix passed to it. For details on how to use these matrices, see the documentation for the Eigen C++ library.\
\
}